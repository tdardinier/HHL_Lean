import MonadicHHL.HHLMonads

open Lean.Order

inductive DivM (α : Type u) where
  | res (x : α)
  | div

def DivM.run {α : Type u} [Inhabited α] : DivM α -> α
  | DivM.res x => x
  | DivM.div => default

instance : Monad DivM where
  pure := DivM.res
  bind := fun x y => match x with
    | DivM.res x => y x
    | DivM.div => DivM.div

class CCPOBot (m : Type u -> Type v)  where
  compBot {α} : m α

class CCPOBotLawful (m : Type u -> Type v) [∀ α, CCPO (m α)] [CCPOBot m] where
  prop {α} : CCPOBot.compBot (m := m) (α := α) = bot

instance : LawfulMonad DivM := by
  refine LawfulMonad.mk' _ ?_ ?_ ?_
  { introv; cases x <;> rfl }
  { introv; rfl }
  introv; cases x <;> rfl

noncomputable instance : CCPO (DivM α)
:= inferInstanceAs (CCPO (FlatOrder .div))
instance : CCPOBot DivM where
  compBot := .div

instance : CCPOBotLawful DivM where
  prop := by simp [Lean.Order.bot, Lean.Order.CCPO.csup,Lean.Order.flat_csup, instCCPOBotDivM]

instance : Lean.Order.MonoBind DivM where
  bind_mono_left := by
    rintro _ _ (_|_) _ _ (_|_) <;> solve_by_elim
  bind_mono_right := by
    rintro _ _ (_|_) <;> solve_by_elim

/- partial loop from MonoBind and CCPO instances -/
@[specialize, inline]
def Loop.forIn.loop {m : Type u -> Type v} [Monad m] [∀ α, CCPO (m α)] [MonoBind m]
  (f : Unit → β → m (ForInStep β)) (b : β) : m β := do
    match ← f () b with
      | ForInStep.done b  => pure b
      | ForInStep.yield b => loop f b
  partial_fixpoint

@[inline]
def Loop.forIn {β : Type u} [Monad m] [∀ α, CCPO (m α)] [MonoBind m]
  (_ : Lean.Loop) (init : β) (f : Unit → β → m (ForInStep β)) : m β :=
  Loop.forIn.loop f init

@[instance high]
instance [md : Monad m] [ccpo : ∀ α, CCPO (m α)] [mono : MonoBind m] : ForIn m Lean.Loop Unit where
  forIn {β} _ := @Loop.forIn m β md ccpo mono

def Assume (P : Prop) [Decidable P] : DivM PUnit :=
  if P then DivM.res () else DivM.div

def nonterminatingDiv : DivM Int := do
  while true do
    return 1
  return 0

def equiv_loop {b : DivM Bool} {C : DivM Unit} :
:
(do while b do C) = (
  do
    Assume b
    C
  )


#print nonterminatingDiv



/- Helper lemmas to reason about a one-step terminating forIn loop -/
theorem Loop.forIn.loop_of_done {m : Type u -> Type v} [Monad m] [∀ α, CCPO (m α)] [MonoBind m]
  {β : Type u} (f : Unit → β → m (ForInStep β)) (b b' : β)
  (h : f () b = pure (ForInStep.done b')) :
  (Loop.forIn.loop (m := m) (β := β) f b) = pure b' := by
  have eq := Loop.forIn.loop.eq_1 (m := m) (β := β) f b
  -- rewrite the definition once with the eq lemma, replace the call by the `pure (ForInStep.done _)` and simplify
  rw [eq, h]
  simp


/- An explicit version of the `while true do return 1` program written with the
   underlying `Loop.forIn.loop` term so proofs can refer to the concrete lambda
   shape generated by the desugaring. This is definitionally the same as the
  `while`-syntax program but avoids fragile macro/desugaring differences.
-/
def nonterminatingDiv : DivM Int := DivM.res (1 : Int)

/- A trivial diverging computation (the bottom of the `DivM` flat order).
   We expose it as `divergingDiv` and prove it equals `DivM.div`. Using the
   `DivM.div` constructor directly keeps the example simple and the proof
  immediate; later we can add a loop-based diverging example if desired.
 -/
def divergingDiv : DivM Int := DivM.div

lemma nonterminatingDiv_is_div : nonterminatingDiv = DivM.res 1 := by rfl
